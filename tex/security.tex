\chapter{Security Analysis}
\label{chap:security}

When we communicate using a steganographic protocol, secrecy is of upmost importance.
We probably communicate in an environment which is very hostile against its communication participants.
Therefore, we should satisfy the most rigorous security requirements we can possibly satisfy.

In \autoref{chap:previous-work}, we have discussed two different definitions of steganographic secrecy.
In \autoref{def:sec-kaptchuk}, we have seen a rigorous definition of steganographic secrecy when we defined \emph{steganographic secrecy against chosen hiddentext attacks}, or SS-CHA.
Later, in \autoref{sec:meteor}, we have introduced the Meteor stegosystem and its definition of security.
In this chapter, we will
\begin{itemize}
	\item compare Meteor's security definition with Hopper's security game,
	\item show that the Meteor stegosystem does not satisfy Hopper's security game,
	\item modify Meteor to improve its security against SS-CHA adversaries.
\end{itemize}

\section{Comparison Of Meteor's And Hopper's Security Game}

In \autoref{sec:prov-sec-steg} and \autoref{sec:meteor}, we have discussed Hopper's and Meteor's definition of steganographic secrecy against chosen hiddentext attackers. In this section, I will compare the security definition of the Meteor stegosystem with Hopper's definition of SS-CHA.

In \autoref{def:sec-kaptchuk}, it is argued that a stegosystem is secure against chosen hiddentext attack, if for all $k \leftarrow KeyGen(1^\lambda)$, the probability of an attacker to distinguish an output of $Encode(k, \cdot, \cdot)$ from the output of a random oracle $\mathcal{O}(\cdot, \cdot)$ is negligible in $\lambda$. In Meteor's security proof, it is argued that Meteor satisfies this security definition by reduction to the underlying PRG.

\begin{theorem}
	Meteor is secure (as of \autoref{def:sec-kaptchuk}) against ppt. adversaries. 
\end{theorem}
\begin{proof}
	Let $\mathcal{A}$ be an attacker against the Meteor stegosystem, i.e. $\mathcal{A}$ can distinguish outputs of $Encode$ from those of a random oracle $\mathcal{O}$. We will now show that $\mathcal{A}$ is also an attacker against the underlying PRG.
	The attacker only sees the outputs $c = c_1 ||c_2 || \dots || c_{|c|}$ of $Encode$ and $\mathcal{O}$, respectively. 
	How could they possibly do that?
	When we take a look at the implementation of $Encode$, we observe that the only output difference to $\mathcal{O}$ in the view of the attacker is the randomness $r$ used to sample $c_i$ from the underlying distribution.
	
	How is $r$ constructed? 
	It is the exclusive-or of $\beta$ bits of $m$ and a pseudorandom value $mask$ from PRG.
	Since $\mathcal{A}$ is an attacker for all messages $m$ in the chosen hiddentext game, we can freely chose a message $m'$ to encode.
	With $m' = 0^\beta$ we get $r = 0^\beta \oplus mask = mask = PRG.Next(k_{prg})$.
	To distinguish $c_i$ from a randomly sampled token, the attacker is able to distinguish $r$ from a truly random value $r'$.
	Therefore, $\mathcal{A}$ can attack the PRG.
	Since we expect the underlying PRG to be secure, $\mathcal{A}$ cannot distinguish $r$ from $r'$ with non-negligible probability in polynomial time.
\end{proof}

But is this sufficient to satisfy Hopper's security game?
Unfortunately not.
In Hopper's $(t,q,l)$-SS-CHA game, an attacker may perform up to $q(k)$ queries.
The aforementioned security proof only considers security against one query.

If $\mathcal{A}$ repeats the same query $m$ and a fixed key $k$, the Meteor system will return the same output, while $\mathcal{O}$ will -- with overwhelming probability~ -- sample an entirely different sequence from the distribution.
After only two queries, $\mathcal{A}$ is able to distinguish Meteor's outputs from those of a random oracle with high likelyhood.

\section{Improve Meteor's Security}

To improve Meteor's security, we have to make the output of $Encode$ non-deterministic. To do that, we take inspiration from symmetric encryption schemes derived from PRG and modify the $Encode$ and $Decode$ algorithms from \autoref{sec:meteor}:

\begin{Pseudocode}[float, caption={Meteor EncodeNonDeterministic Algorithm}, label={alg:encode}]
algorithm $EncodeNonDeterministic_{\mathcal{M}}^{\beta,\gamma}(k_{prg}, m, \mathcal{H})$
	Output: Stegotext message $c$
	$IV \leftarrow\$ \{0,1\}^\gamma$
	$c \leftarrow \epsilon,~ j \leftarrow 0,~ n \leftarrow 0$
	while $j < |IV|$ do
		$c_i \leftarrow Sample_{\mathcal{M}}^\beta(\mathcal{H}, IV[j: j+\beta])$
		$\mathcal{R} = Recover_{\mathcal{M}}^\beta(\mathcal{H}, c_i)$
		$j_i \leftarrow LenPrefix^\beta(\mathcal{R})$
		$c \leftarrow c || c_i,~ j \leftarrow j + j_i,~ \mathcal{H} \leftarrow \mathcal{H}||c_i$
	while $n < |m|$ do
		$mask \leftarrow PRG.Next(k_{prg}||IV)$
		$r \leftarrow m[n:n+\beta] \oplus mask$
		$c_i \leftarrow Sample_{\mathcal{M}}^\beta(\mathcal{H}, r)$
		$\mathcal{R} = Recover_{\mathcal{M}}^\beta(\mathcal{H}, c_i)$
		$n_i \leftarrow LenPrefix^\beta(\mathcal{R})$
		$c \leftarrow c || c_i, n \leftarrow n+n_i, \mathcal{H} \leftarrow \mathcal{H}||c_i,~ IV \leftarrow IV+1$
	Output $c$
\end{Pseudocode}

\begin{Pseudocode}[float, caption={Meteor DecodeNonDeterministic Algorithm}, label={alg:decode}]
algorithm $DecodeNonDeterministic_{\mathcal{M}}^{\beta,\gamma}(k_{prg}, c, \mathcal{H})$
	Output: Plaintext message $m$
	$m \leftarrow \epsilon,~ IV \leftarrow \epsilon$
	Parse $c$ as $\{ c_0, c_1, \dots, c_{|c|-1} \}$
	for $i \in \{0, 1, \dots, |c|-1 \}$ do
		$\mathcal{R} = Recover_{\mathcal{M}}^\beta(\mathcal{H}, c_i)$
		$m_i \leftarrow Prefix^\beta(\mathcal{R})$
		if $n < \gamma$ do
			$IV \leftarrow IV || m_i$
		else
			$mask \leftarrow PRG.Next(k_{prg} || IV)$
			$m \leftarrow m || (m_i \oplus mask[0: |m_i|]$
			$\mathcal{H} \leftarrow \mathcal{H}||c_i,~ IV \leftarrow IV + 1$
	Output $m$
\end{Pseudocode}

