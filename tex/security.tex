\chapter{Security Analysis}
\label{chap:security}

When we communicate using a steganographic protocol, secrecy is of upmost importance.
We probably communicate in an environment that is very hostile against its communication participants.
Therefore, we should satisfy the most rigorous security requirements we can.

In \autoref{chap:previous-work}, we discussed two different definitions of steganographic secrecy.
In \autoref{def:sec-hopper}, we have established a rigorous definition of steganographic secrecy against chosen hiddentext attackers called SS-CHA.
Later, in \autoref{sec:meteor}, we have introduced the Meteor stegosystem and its definition of security.
In this chapter, we will compare Meteor's security with Hopper's definition of SS-CHA.
Afterwards, we will show that the Meteor stegosystem is in fact insecure with respect to Hopper's definition of SS-CHA secrecy.
In conclusion, we will introduce a modification to the Meteor stegosystem to improve its security against SS-CHA adversaries by replacing the one-time pad in Meteor with a symmetric encryption scheme (SES).

\section{Comparison of Meteor's and Hopper's Steganographic Secrecy}

In \autoref{sec:prov-sec-steg} and \autoref{sec:meteor}, we have discussed Hopper's and Meteor's definition of steganographic secrecy against chosen hiddentext attackers. 
In this section, we will compare the security definition of the Meteor stegosystem with Hopper's definition of SS-CHA and see that Meteor's definition is weaker than Hopper's.

In \autoref{def:sec-kaptchuk}, it is argued that a stegosystem is secure against chosen hiddentext attack if for all $k \leftarrow KeyGen(1^\lambda)$ the probability of an attacker to distinguish an output of $Encode(k, \cdot, \cdot)$ from the output of a random oracle $\mathcal{O}(\cdot, \cdot)$ is negligible in $\lambda$. In Meteor's security proof, it is argued that Meteor satisfies this security definition by reduction to the underlying PRG.

\begin{theorem}
	Meteor is secure (\autoref{def:sec-kaptchuk}) against ppt. adversaries. 
\label{thm:meteor-secure}
\end{theorem}
\begin{proof}
	Let $\mathcal{A}$ be an attacker against the Meteor stegosystem, i.e. $\mathcal{A}$ can distinguish outputs of $Encode$ from those of a random oracle $\mathcal{O}$. 
	We will now show that $\mathcal{A}$ is also an attacker against the underlying PRG.
	The attacker only sees the outputs $c = c_0 ||c_1 || \dots || c_{\tau}$ of $Encode$ and $\mathcal{O}$, respectively.
	When we take a look at the implementation of $Encode$, we observe that the only output difference to $\mathcal{O}$ in the view of the attacker is the randomness $r$ used to sample $c_i$ from the underlying distribution.
	
	How is $r$ constructed? 
	It is the exclusive-or of $\beta$ bits of $m$ and a pseudorandom value $mask$ from PRG.
	Since $mask$ is an output of a pseudorandom generator which we expect to be indistinguishable from true randomness, the exclusive-or of $mask$ with some other value is indistinguishable from true randomness as well.
	But to distinguish the output of $Encode$ from some oracle $\mathcal{O}$, the attacker has to distinguish $r$ from a randomly sampled token, i.e. the attacker has to distinguish $r$ from a truly random value $r'$.
	
	Therefore, $\mathcal{A}$ can be used to attack the PRG.
	Since we expect the underlying PRG to be secure, $\mathcal{A}$ cannot distinguish $r$ from $r'$ with non-negligible probability in polynomial time.
\end{proof}

But is this sufficient to satisfy Hopper's definition of steganographic secrecy?
Unfortunately not.
In Hopper's $(t,q,l)$-SS-CHA game, an attacker may perform up to $q(k)$ queries.
The aforementioned security proof only considers security against one query.
If $\mathcal{A}$ repeats the same query twice, the Meteor system will return the same output, while $\mathcal{O}$ will~ --~ with overwhelming probability~ --~ sample an entirely different sequence from the distribution.
After only two queries, $\mathcal{A}$ is able to distinguish Meteor's outputs from those of a random oracle with high certainty.


\section{Improve Meteor's Security}

To improve Meteor's security, we have to randomize the output of $Encode$, i.e. on each invocation with the same inputs, $Encode$ should, with overwhelming probability, return a different stegotext while retaining indistinguishability from random sampling.

To achieve that we have to introduce a new cryptographic primitive, symmetric encryption schemes (SES) in counter (CTR) mode based on a pseudorandom function (PRF) $F$.
We introduce a definition of a SES in \autoref{fig:ses} which is a variant of that introduced in \cite{Berndt2017}.
There it is argued that SES satisfies the IND\$-CPA property if F is a secure pseudorandom function.

The idea behind encryption in SES-CTR is simple:
First, split the message $m$ into $n$ blocks of size $F.in(\lambda)$ specific to $F$.
Then choose an $IV$ of size $F.in(\lambda)$ at random.
It is important to not reuse an $IV$ with a given key $k$ to retain One-Time-Pad security.
Now, for each block $m_i$, use $F.Eval$ to generate the pseudorandom value $r = F.Eval(k, IV+i)$.
Afterwards, calculate the exclusive or of $r$ and $m_i$ to get the next block $c_i$.
The ciphertext of size $(n+1)\cdot F.in(\lambda)$ is the $IV$ concatenated with ciphertext blocks $c_i$.

Decryption is similar to encryption.
First, split $c$ in $n+1$ blocks of size $F.in(\lambda)$.
Interpret the first block of $c$ as $IV$.
Afterwards, analogously to encryption, for each block $c_i$, calculate $r = F.Eval(k, IV+i)$.
Now, calculate the exclusive or of $r$ and $c_i$ to recover the message block $m_i = c_i \oplus r$.

Now that we have established the concept of an SES, we still need to find $F$ which is a PRF.
In practice, we can use AES as $F$, which is believed to be a pseudorandom permutation (PRP), with key $k$ and messages $IV+i$.

\begin{figure}[htbp]%
	\centering%
	\begin{Pseudocode}
algorithm $SES.Encrypt_F(k, m=m_1 m_2 \dots m_n \in \{0,1\}^{n\cdot F.in(\lambda)})$
	Output: Ciphertext $c$
	$\lambda = |k|$
	$IV \leftarrowS \{0,1\}^{F.in(\lambda)}$
	for $i \in \{ 1, 2, \dots, n \}$ do
		$c_i \leftarrow F.Eval(k, (IV+i) \mod 2^{F.in(\lambda)}) \oplus m_i$
	Output $IV||c_1||c_2||\dots||c_n$
	\end{Pseudocode}%
	\begin{Pseudocode}
algorithm $SES.Decrypt_F(k, c=c_0 c_1 \dots c_n \in \{0,1\}^{(n+1)\cdot F.in(\lambda)})$
	Output: cleartext $m$
	$\lambda = |k|$
	$IV \leftarrow c_0$
	for $i \in \{ 1, 2, \dots, n \}$ do
		$m_i \leftarrow F.Eval(k, (IV+i) \mod 2^{F.in(\lambda)}) \oplus c_i$
	Output $m_1||m_2||\dots||m_n$
	\end{Pseudocode}%
	\caption{Symmetric Encryption Scheme (SES) in counter (CTR) mode}%
	\label{fig:ses}%
\end{figure}%

\todo{Figure -> Listing?}

In \autoref{alg:encode-nd}, we use the SES defined in \autoref{fig:ses} to encrypt the hiddentext message.
Since $IV$ as well as all blocks $c_i$ are indistinguishable from randomness, the entire output of $SES.Encrypt_F$ is indistinguishable from randomness.
In \autoref{alg:decode-nd}, the SES is used to decrypt the hiddentext.
Therefore, an attacker cannot distinguish the stegotext tokens from those sampled using a random oracle $\mathcal{O}$.

These modifications improve Meteor's security against SS-CHA adversaries.
Repeated invocations of $EncodeRandomized$ return different stegotexts with overwhelming probability.
Since $SES$ is IND\$-CPA secure we can, with the same reduction as in Theorem \ref{thm:meteor-secure}, show SS-CHA secrecy against polynomial attackers as long as the same $IV$ is not generated twice, which is -- in practice -- very unlikely for sufficient $IV$ lengths.


\begin{Pseudocode}[float, caption={
$EncodeRandomized$ algorithm.
This algorithm differs from the original $Encode$ algorithm by using $SES$ to encrypt the message.
The ciphertext (which is indistinguishable from randomness and indeterministic) is then used to sample from $\mathcal{M}$.
}, label={alg:encode-nd}]
algorithm $EncodeRandomized_{\mathcal{M}}^{\beta}(k_{prg}, m, h)$
	Output: Stegotext message $c$
	$c \leftarrow \epsilon,~ i \leftarrow 0,~ n \leftarrow 0$
	$r \leftarrow SES.Encrypt(k, m)$
	while $n < |r|$ do
		$c_i \leftarrow Sample_{\mathcal{M}}^\beta(h, r[n: n+\beta])$
		$\mathcal{R} \leftarrow Recover_{\mathcal{M}}^\beta(h, c_i)$
		$n_i \leftarrow LenPrefix^\beta(\mathcal{R})$
		$c \leftarrow c || c_i,~ n \leftarrow n+n_i,~ h \leftarrow h||c_i,~ i \leftarrow i + 1$
	Output $c$
\end{Pseudocode}
\begin{Pseudocode}[float, caption={
$DecodeRandomized$ algorithm.
This algorithm differs from the original $Decode$ algorithm by using $SES$ to decrypt the stegotext.
}, label={alg:decode-nd}]
algorithm $DecodeRandomized_{\mathcal{M}}^{\beta}(k_{prg}, c, h)$
	Output: Plaintext message $m$
	$m \leftarrow \epsilon,~ n \leftarrow 0,~ r \leftarrow \epsilon$
	Parse $c$ as $c_0 || c_1 || \dots || c_{\tau}$
	for $i \in \{ 0, 1, \dots, \tau \}$ do
		$\mathcal{R} \leftarrow Recover_{\mathcal{M}}^\beta(h, c_i)$
		$r_i \leftarrow Prefix^\beta(\mathcal{R})$
		$r \leftarrow r || r_i$
		$h \leftarrow h||c_i$
	$m \leftarrow SES.Decrypt(k, r)$
	Output $m$
\end{Pseudocode}